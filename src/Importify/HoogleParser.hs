-- | This module contains parser for files, generated by
-- @stack hoogle@ command into @haskell-names@ library's 'N.Symbol'
-- data type.

module Importify.HoogleParser
       ( parseHoogle
       ) where

import           Universum

import           Data.Bifunctor         (first)
import           Language.Haskell.Exts  (ModuleName (..))
import qualified Language.Haskell.Names as N
import           Text.Megaparsec        (ParseError (..), alphaNumChar, anyChar, between,
                                         char, digitChar, letterChar, lowerChar, many,
                                         manyTill, notFollowedBy, oneOf, option, optional,
                                         parse, parseErrorPretty, sepBy1, some, space,
                                         string, try, upperChar)
import           Text.Megaparsec.Text   (Parser)

-- text :: String -> Parser Text
-- text t = toText <$> string t

-- txtSpace :: String -> Parser Text
-- txtSpace s = space *> text s

keyword :: String -> Parser ()
keyword w = string w *> notFollowedBy alphaNumChar *> space

-- | Parser for uppercase identifiers.
upperIdP :: Parser String
upperIdP = liftA2 (:) upperChar (many alphaNumChar)

-- | Parser for lowercase identifiers.
lowerIdP :: Parser String
lowerIdP = liftA2 (:) lowerChar (many alphaNumChar)

-- | Parser @Module.Name.Identifiers@
moduleNameP :: Parser String
moduleNameP = intercalate "." <$> upperIdP `sepBy1` char '.'

-- | Parses content of @hoogle@ file into corresponding list of 'N.Symbol'.
parseHoogle :: Text -> Either String [N.Symbol]
parseHoogle = first parseErrorPretty . parse hoogleDatabaseP ""

hoogleDatabaseP :: Parser [N.Symbol]
hoogleDatabaseP = do
    keyword "module"
    moduleName <- moduleNameP
    many $ skippedPartP *> symbolP (ModuleName () moduleName)

symbolP :: ModuleName () -> Parser N.Symbol
symbolP symbolModule = typeP
                   <|> dataP
                   <|> newtypeP
                   <|> classP
                   <|> funP
  where
    typeP :: Parser N.Symbol
    typeP = undefined

    dataP :: Parser N.Symbol
    dataP = undefined

    newtypeP :: Parser N.Symbol
    newtypeP = undefined

    classP :: Parser N.Symbol
    classP = undefined

    funP :: Parser N.Symbol
    funP = undefined

skippedPartP :: Parser ()
skippedPartP = instanceP
  where
    instanceP :: Parser ()
    instanceP = undefined

-- module HoogleExample1
-- foo :: Int -> IO ()
-- bar :: Int -> IO ()
-- data Shape
-- Circle :: Float -> Float -> Float -> Shape
-- Rectangle :: Float -> Float -> Float -> Float -> Shape
-- data Person
-- Person :: String -> String -> Person
-- [firstName] :: Person -> String
-- [lastName] :: Person -> String
-- class Test1 t
-- meth1 :: Test1 t => t -> t -> t
-- meth2 :: (Test1 t, Read a) => a -> t
-- class Show t => Test2 t
-- testMethod :: Test2 t => t -> String
-- type Foo = String
-- newtype Identifier a
-- MkId :: String -> Identifier a
-- [getId] :: Identifier a -> String
-- instance GHC.Show.Show HoogleExample1.Person
-- instance GHC.Base.Monoid HoogleExample1.Shape
